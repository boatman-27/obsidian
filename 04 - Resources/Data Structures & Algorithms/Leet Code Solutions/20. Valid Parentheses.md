---
tags:
  - newLeetCode
  - easy
  - stacks
Difficulty: easy
link: https://leetcode.com/problems/valid-parentheses/
---
# [Problem 20] Valid Parentheses

## Problem Statement

we have a string `s` containing different parentheses`'('`, `')'`, `'{'`, `'}'`, `'['` and `']'`, we need to see if the string is valid, which means they:
1. Open brackets must be closed by the same type of brackets.
2. Open brackets must be closed in the correct order.
3. Every close bracket has a corresponding open bracket of the same type.

---
## Examples 
### **Example 1:**
	**Input:** s = "()"
	**Output:** true
### **Example 2:**
	**Input:** s = "()[]{}"
	**Output:** true
### **Example 3:**
	**Input:** s = "(]"
	**Output:** false
### **Example 4:**
	**Input:** s = "([])"
	**Output:** true
### **Example 5:**
	**Input:** s = "([)]"
	**Output:** false

---
## Approaches 
i was thinking of using a stack, entering the parentheses at the top and we should have a hashmap as well, to match opening and closing...

then as we for loop through the string, we check if the rune to be added is a closing tag, if it is then we check if the top element (if any) is the openning tag of the rune if so, we pop the top, if not return false.

then we check it the stack is empty or not.

---
## Code (in Go)
```go
package main

import "fmt"

type Node struct {
	parentheses rune
	Next        *Node
}

type Stack struct {
	head   *Node
	length int
}

func (s *Stack) Push(data rune) {
	newNode := &Node{parentheses: data, Next: s.head}
	s.head = newNode
	s.length++
}

func (s *Stack) Pop() {
	poppedNode := s.head
	s.head = poppedNode.Next
	s.length--
}

func (s *Stack) Peek() rune {
	return s.head.parentheses
}

func (s *Stack) Print() {
	current := s.head
	for current != nil {
		fmt.Printf("%c -> ", current.parentheses)
		current = current.Next
	}
	fmt.Println("nil")
}

func isValid(s string) bool {
	if len(s)%2 != 0 {
		return false
	}

	paren := map[rune]rune{
		'(': ')',
		'{': '}',
		'[': ']',
	}

	stack := &Stack{}
	for _, r := range s {
		if _, ok := paren[r]; !ok {
            
            if stack.length == 0 {
                return false 
            }
			top := stack.Peek()
			if string(paren[top]) != string(r) {
				return false
			}
			stack.Pop()
		} else {
			stack.Push(r)
		}
	}
	if stack.length == 0 {
		return true
	} else {
		return false
	}
}

func main() {
	s := "(("
	fmt.Println(isValid(s))
}
```