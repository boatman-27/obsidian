---
tags:
  - newLeetCode
  - easy
  - binary_tree
Difficulty: easy
link: https://leetcode.com/problems/path-sum/description/?envType=problem-list-v2&envId=breadth-first-search
---
# [Problem 112] Path Sum

## Problem Statement
Given the `root` of a binary tree and an integer `targetSum`, return `true` if the tree has a **root-to-leaf** path such that adding up all the values along the path equals `targetSum`.

A **leaf** is a node with no children.

---
## Examples 
**Example 1:**

![](https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg)

**Input:** root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
**Output:** true
**Explanation:** The root-to-leaf path with the target sum is shown.

**Example 2:**

![](https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg)

**Input:** root = [1,2,3], targetSum = 5
**Output:** false
**Explanation:** There are two root-to-leaf paths in the tree:
(1 --> 2): The sum is 3.
(1 --> 3): The sum is 4.
There is no root-to-leaf path with sum = 5.

**Example 3:**

**Input:** root = [], targetSum = 0
**Output:** false
**Explanation:** Since the tree is empty, there are no root-to-leaf paths.

---
## Approaches 

if root is nil then false, else we add the value when enqueuing, we stop when we reach a leaf node, if the sum is equal to target then true else if we go through the entire tree and its not equal to target return false 

---
## Code (in Go)
```go
package main

type TreeNode struct {
	Val   int
	Left  *TreeNode
	Right *TreeNode
}

type nodeSum struct {
	node       *TreeNode
	currentSum int
}

func hasPathSum(root *TreeNode, targetSum int) bool {
	if root == nil {
		return false
	}

	q := []*nodeSum{{root, root.Val}}
	for len(q) != 0 {
		current := q[0]
		q = q[1:]

		if current.node.Left == nil && current.node.Right == nil && current.currentSum == targetSum {
			return true
		}

		if current.node.Left != nil {
			q = append(q, &nodeSum{current.node.Left, current.currentSum + current.node.Left.Val})
		}
		if current.node.Right != nil {
			q = append(q, &nodeSum{current.node.Right, current.currentSum + current.node.Right.Val})
		}
	}

	return false
}
```