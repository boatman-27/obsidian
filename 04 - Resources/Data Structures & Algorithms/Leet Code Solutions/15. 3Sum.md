---
tags:
  - newLeetCode
  - medium
  - two-pointer
Difficulty: medium
link: https://leetcode.com/problems/3sum/description/
---
# [Problem 15] 3 sum

## Problem Statement

Given an integer array nums, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k] == 0`.

Notice that the solution set must not contain duplicate triplets.

---
## Examples 

**Example 1:**

**Input:** nums = [-1,0,1,2,-1,-4]
**Output:** [[-1,-1,2],[-1,0,1]]
**Explanation:** 
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.
The distinct triplets are [-1,0,1] and [-1,-1,2].
Notice that the order of the output and the order of the triplets does not matter.

**Example 2:**

**Input:** nums = [0,1,1]
**Output:** []
**Explanation:** The only possible triplet does not sum up to 0.

**Example 3:**

**Input:** nums = [0,0,0]
**Output:** [[0,0,0]]
**Explanation:** The only possible triplet sums up to 0.

---
## Approaches 

we need an 3 elements, current, ele1 and ele2. current only moves if its the same as the element before OR when ele1 >= ele2. we set ele1 to be current + 1 and ele2 is the last element. if the sum is < 0 then increment ele1, if sum > 0, decrement ele2. if sum == 0 add to result array and move ele1 and ele2 inward 

then keep incrementing ele1 as long as ele1 < ele2 AND element at ele1 is the same as previous and do the same for ele2. 

---
## Code (in Go)
```go
package main  
  
import (  
    "fmt"  
    "sort")  
  
func sum(num1, num2, num3 int) int {  
    return num1 + num2 + num3  
}  
  
func threeSum(nums []int) [][]int {  
    result := make([][]int, 0)  
    sort.Ints(nums)  
  
    for current := 0; current < len(nums)-2; current++ {  
       if current > 0 && nums[current] == nums[current-1] {  
          continue  
       }  
  
       ele1 := current + 1  
       ele2 := len(nums) - 1  
  
       for ele1 < ele2 {  
          s := sum(nums[current], nums[ele2], nums[ele1])  
  
          if s == 0 {  
             result = append(result, []int{nums[current], nums[ele1], nums[ele2]})  
             ele1++  
             ele2--  
  
             for ele1 < ele2 && nums[ele1] == nums[ele1-1] {  
                ele1++  
             }  
             for ele1 < ele2 && nums[ele2] == nums[ele2+1] {  
                ele2--  
             }  
          } else if s < 0 {  
             ele1++  
          } else {  
             ele2--  
          }  
       }  
  
    }  
  
    return result  
}  
  
func main() {  
    nums := []int{-1, 0, 1, 2, -1, -4}  
  
    fmt.Println(threeSum(nums))  
}
```