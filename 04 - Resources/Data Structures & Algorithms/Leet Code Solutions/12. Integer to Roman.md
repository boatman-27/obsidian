---
tags:
  - newLeetCode
  - medium
  - hash_table
Difficulty: medium
link: https://leetcode.com/problems/integer-to-roman/
---
# [Problem #] Problem Title

## Problem Statement
given an integer we should return the roman value... some rules:

Roman numerals are formed by appending the conversions of decimal place values from highest to lowest. Converting a decimal place value into a Roman numeral has the following rules:

- If the value does not start with 4 or 9, select the symbol of the maximal value that can be subtracted from the input, append that symbol to the result, subtract its value, and convert the remainder to a Roman numeral.
- If the value starts with 4 or 9 use the **subtractive form** representing one symbol subtracted from the following symbol, for example, 4 is 1 (`I`) less than 5 (`V`): `IV` and 9 is 1 (`I`) less than 10 (`X`): `IX`. Only the following subtractive forms are used: 4 (`IV`), 9 (`IX`), 40 (`XL`), 90 (`XC`), 400 (`CD`) and 900 (`CM`).
- Only powers of 10 (`I`, `X`, `C`, `M`) can be appended consecutively at most 3 times to represent multiples of 10. You cannot append 5 (`V`), 50 (`L`), or 500 (`D`) multiple times. If you need to append a symbol 4 times use the **subtractive form**.

---
## Examples 
### **Example 1:**

**Input:** num = 3749

**Output:** "MMMDCCXLIX"

**Explanation:**

3000 = MMM as 1000 (M) + 1000 (M) + 1000 (M)
 700 = DCC as 500 (D) + 100 (C) + 100 (C)
  40 = XL as 10 (X) less of 50 (L)
   9 = IX as 1 (I) less of 10 (X)
Note: 49 is not 1 (I) less of 50 (L) because the conversion is based on decimal places

### **Example 2:**

**Input:** num = 58

**Output:** "LVIII"

**Explanation:**

50 = L
 8 = VIII

### **Example 3:**

**Input:** num = 1994

**Output:** "MCMXCIV"

**Explanation:**

1000 = M
 900 = CM
  90 = XC
   4 = IV
   
---
## Approaches 
make a hashmap of the given roman numerals to their values, run through said hashmap and divide by the number, keep count and then add all to a string


so this failed bc the loop would go randomly between the elements in the hashmap


## approach 2

we will keep the hashmap but we will make an array for the symbols, loop through that, get the corresponding value from the map and subtract as long the number is greater than the value of the symbol 

---
## Code (in Go)
```go
package main

import "fmt"

func intToRoman(num int) string {
	var res string

	romanValue := map[string]int{
		"M":  1000,
		"CM": 900,
		"D":  500,
		"CD": 400,
		"C":  100,
		"XC": 90,
		"L":  50,
		"XL": 40,
		"X":  10,
		"IX": 9,
		"V":  5,
		"IV": 4,
		"I":  1,
	}

	romans := []string{"M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"}

	for _, symbol := range romans {
		value := romanValue[symbol]
		count := 0
		for num >= value {
			num -= value
			count++
		}

		for count > 0 {
			res += symbol
			count--
		}
	}

	return res
}

func main() {
	num := 3749
	fmt.Println(intToRoman(num))
}
```