---
tags:
  - newLeetCode
  - easy
  - stacks
Difficulty: easy
link: https://leetcode.com/problems/implement-queue-using-stacks/description/?envType=problem-list-v2&envId=queue
---
# [Problem 232] Implement Queue using Stacks

## Problem Statement
Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (`push`, `peek`, `pop`, and `empty`).

Implement the `MyQueue` class:
- `void push(int x)` Pushes element x to the back of the queue.
- `int pop()` Removes the element from the front of the queue and returns it.
- `int peek()` Returns the element at the front of the queue.
- `boolean empty()` Returns `true` if the queue is empty, `false` otherwise.

**Notes:**
- You must use **only** standard operations of a stack, which means only `push to top`, `peek/pop from top`, `size`, and `is empty` operations are valid.
- Depending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack's standard operations.

---
## Examples 
### **Example 1:**
	**Input**
	["MyQueue", "push", "push", "peek", "pop", "empty"]
	[[], [1], [2], [], [], []]
	**Output**
	[null, null, null, 1, 1, false]
	
	**Explanation**
	MyQueue myQueue = new MyQueue();
	myQueue.push(1); // queue is: [1]
	myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)
	myQueue.peek(); // return 1
	myQueue.pop(); // return 1, queue is [2]
	myQueue.empty(); // return false
---
## Approaches 

---
## Code (in Go)
```go
package main

type MyQueue struct {
	arr []int
}

func Constructor() MyQueue {
	return MyQueue{arr: []int{}}
}

func (this *MyQueue) Push(x int) {
	this.arr = append(this.arr, x)
}

func (this *MyQueue) Pop() int {
	if len(this.arr) == 0 {
		return -1
	}

	val := this.arr[0]
	this.arr = this.arr[1:]
	return val
}

func (this *MyQueue) Peek() int {
	return this.arr[0]
}

func (this *MyQueue) Empty() bool {
	return len(this.arr) == 0
}
```